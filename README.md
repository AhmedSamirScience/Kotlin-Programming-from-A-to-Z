
<body>

<h1>Kotlin Implicit Backing Field Demonstration</h1>

<p>This repository contains a Kotlin application that demonstrates the use of an implicit backing field in Kotlin. The <code>x</code> and <code>y</code> properties in this example have custom getters and setters that interact with an implicitly generated backing field. The backing field is represented by the <code>field</code> keyword and is automatically created by the Kotlin compiler.</p>

<h2>Code Overview</h2>

<pre>
<code>
/**
 * This class demonstrates the use of an implicit backing field in Kotlin.
 *
 * The `x` and `y` properties have custom getters and setters that interact with an implicitly generated
 * backing field. The backing field is represented by the `field` keyword and is automatically created
 * by the Kotlin compiler.
 */

class GameObject {
    var x: Int = 0
        // Custom getter using the implicit backing field
        get() = field
        // Custom setter with validation, using the implicit backing field
        set(value) {
            if (value >= 0) {
                field = value
            } else {
                println("Invalid value for x: $value (must be >= 0)")
            }
        }

    var y: Int = 0
        // Custom getter using the implicit backing field
        get() = field
        // Custom setter with validation, using the implicit backing field
        set(value) {
            if (value >= 0) {
                field = value
            } else {
                println("Invalid value for y: $value (must be >= 0)")
            }
        }
}

fun main() {
    val obj = GameObject()

    // Display initial values of x and y
    println("initial obj.x: ${obj.x}, obj.y: ${obj.y}")

    // Set new values for x and y
    obj.x = 10
    obj.y = 10
    println("updated obj.x: ${obj.x}, obj.y: ${obj.y}")

    // Attempt to set invalid values
    obj.x = -5
    obj.y = -5
    println("after invalid update obj.x: ${obj.x}, obj.y: ${obj.y}")
}

/*
 * Output:
 * initial obj.x: 0, obj.y: 0
 * updated obj.x: 10, obj.y: 10
 * Invalid value for x: -5 (must be >= 0)
 * Invalid value for y: -5 (must be >= 0)
 * after invalid update obj.x: 10, obj.y: 10
 */

/**
 * Explanation:
 *
 * - The `x` and `y` properties have custom getters and setters that use the implicit backing field (`field`).
 * - The custom setters validate the incoming value to ensure it is non-negative. If the value is valid, it is stored in the backing field.
 * - If an invalid value (negative) is provided, the setter prints an error message, and the backing field is not updated.
 * - The initial values for `x` and `y` are both `0`, as set during their declaration.
 * - After setting valid values, the properties are updated accordingly.
 * - When invalid values are attempted, the properties remain unchanged, demonstrating the validation logic in the setters.
 */

/**
 * Summary:
 * Implicit Backing Field: The field keyword represents the underlying storage of a property. It is automatically generated by the Kotlin compiler when custom getters and setters are defined.
 * Custom Getters and Setters: Custom logic can be applied within the getters and setters. In this example, the setters validate that the incoming values for x and y are non-negative before updating the backing field.
 * Error Handling: If an invalid value is provided (e.g., a negative number), the setter prints an error message, and the property is not updated. This ensures that the property maintains valid data.
 * This class.kt file provides a complete example of how to use implicit backing fields with custom getters and setters in Kotlin, with detailed explanations and code demonstrating the functionality and benefits of this approach.
 */
</code>
</pre>

<h3>Implicit Backing Field in Kotlin</h3>

<ul>
    <li><strong>Implicit Backing Field:</strong> The <code>field</code> keyword represents the underlying storage of a property. It is automatically generated by the Kotlin compiler when custom getters and setters are defined.</li>
    <li><strong>Custom Getters and Setters:</strong> Custom logic can be applied within the getters and setters. In this example, the setters validate that the incoming values for <code>x</code> and <code>y</code> are non-negative before updating the backing field.</li>
    <li><strong>Error Handling:</strong> If an invalid value is provided (e.g., a negative number), the setter prints an error message, and the property is not updated. This ensures that the property maintains valid data.</li>
</ul>

<h2>How to Run</h2>

<ol>
    <li>Clone the repository:
        <pre><code>git clone &lt;repository-url&gt;</code></pre>
    </li>
    <li>Open the project in your preferred IDE (e.g., IntelliJ IDEA, Android Studio).</li>
    <li>Navigate to the <code>main</code> function.</li>
    <li>Run the <code>main</code> function to see the output of different examples demonstrating the use of implicit backing fields with custom getters and setters.</li>
</ol>

<h2>License</h2>

<p>This project is licensed under the MIT License.</p>

<h2>Author</h2>

<p><strong>Ahmed Samir</strong> - Software Engineer</p>

</body>
</html>
